from unittest import TestCase
from a38 import fields
from a38 import validation
from a38.builder import Builder
from decimal import Decimal
import datetime
import io

NS = "http://ivaservizi.agenziaentrate.gov.it/docs/xsd/fatture/v1.2"


class FieldTestMixin:
    field_class = fields.Field

    def get_field(self, **kw):
        f = self.field_class(**kw)
        f.set_name("test")
        return f

    def test_xmltag(self):
        # XML tag is autogenerated from the field name
        f = self.get_field()
        self.assertEqual(f.get_xmltag(), "Test")

        # But can be overridden with the xmltag argument
        f = self.get_field(xmltag="OtherName")
        self.assertEqual(f.get_xmltag(), "OtherName")

    def test_empty(self):
        f = self.get_field()

        # Validating a field with null=False raises an error
        with self.assertRaises(validation.ValidationError):
            f.validate(None)

        # But null values are tolerated outside validation, while structures
        # are being filled
        self.assertIsNone(f.clean_value(None))

        # Values set to None are skipped in XML
        self.assertIsNone(self.to_xml(f, None))

    def test_nullable(self):
        f = self.get_field(null=True)
        self.assertIsNone(f.validate(None))
        self.assertIsNone(f.clean_value(None))

    def test_construct_default(self):
        f = self.get_field()
        self.assertIsNone(f.get_construct_default())

    def test_value(self):
        f = self.get_field(null=True)
        self.assertEqual(f.validate("value"), "value")

    def test_default(self):
        f = self.get_field(default="default")
        self.assertEqual(f.clean_value(None), "default")
        self.assertEqual(self.to_xml(f, None), "<Test>default</Test>")

    def test_xml(self):
        f = self.get_field(null=True)
        self.assertEqual(self.to_xml(f, "value"), "<Test>value</Test>")

    def to_xml(self, field, value):
        """
        Serialize the field to XML. Returns None is the field generated no
        value in the XML.
        """
        builder = Builder()
        field.to_xml(builder, value)
        tree = builder.get_tree()
        if tree.getroot() is None:
            return None
        with io.StringIO() as out:
            tree.write(out, encoding="unicode")
            return out.getvalue()


class TestField(FieldTestMixin, TestCase):
    pass


class TestStringField(FieldTestMixin, TestCase):
    field_class = fields.StringField

    def test_value(self):
        f = self.get_field()
        self.assertEqual(f.validate("value"), "value")
        self.assertEqual(f.validate(12), "12")

    def test_default(self):
        f = self.get_field(default="default")
        self.assertEqual(f.clean_value(None), "default")
        self.assertEqual(self.to_xml(f, None), "<Test>default</Test>")

    def test_length(self):
        f = self.get_field(length=3)
        with self.assertRaises(validation.ValidationError):
            f.validate("va")
        with self.assertRaises(validation.ValidationError):
            f.validate("valu")
        with self.assertRaises(validation.ValidationError):
            f.validate(1.15)
        self.assertEqual(f.validate("val"), "val")
        self.assertEqual(f.validate(1.2), "1.2")

    def test_min_length(self):
        f = self.get_field(min_length=3)
        with self.assertRaises(validation.ValidationError):
            f.validate("va")
        self.assertEqual(f.validate("valu"), "valu")
        self.assertEqual(f.validate("val"), "val")
        self.assertEqual(f.validate(1.2), "1.2")
        self.assertEqual(f.validate(1.15), "1.15")

    def test_max_length(self):
        f = self.get_field(max_length=3)
        self.assertEqual(f.validate("v"), "v")
        self.assertEqual(f.validate("va"), "va")
        self.assertEqual(f.validate("val"), "val")
        with self.assertRaises(validation.ValidationError):
            f.validate("valu")

    def test_choices(self):
        f = self.get_field(choices=("A", "B"))
        self.assertEqual(f.validate("A"), "A")
        self.assertEqual(f.validate("B"), "B")
        with self.assertRaises(validation.ValidationError):
            f.validate("C")
        with self.assertRaises(validation.ValidationError):
            f.validate("a")
        with self.assertRaises(validation.ValidationError):
            f.validate(None)

    def test_choices_nullable(self):
        f = self.get_field(choices=("A", "B"), null=True)
        self.assertEqual(f.validate("A"), "A")
        self.assertEqual(f.validate("B"), "B")
        self.assertEqual(f.validate(None), None)
        with self.assertRaises(validation.ValidationError):
            f.validate("C")
        with self.assertRaises(validation.ValidationError):
            f.validate("a")

    def test_xml(self):
        f = self.get_field(null=True)
        self.assertEqual(self.to_xml(f, "value"), "<Test>value</Test>")


class TestIntegerField(FieldTestMixin, TestCase):
    field_class = fields.IntegerField

    def test_value(self):
        f = self.get_field()
        self.assertEqual(f.validate(12), 12)
        self.assertEqual(f.validate("12"), 12)
        self.assertEqual(f.validate(12.3), 12)
        with self.assertRaises(validation.ValidationError):
            f.validate("foo")

    def test_default(self):
        f = self.get_field(default=7)
        self.assertEqual(f.clean_value(None), 7)
        self.assertEqual(self.to_xml(f, None), "<Test>7</Test>")

    def test_max_length(self):
        f = self.get_field(max_length=3)
        self.assertEqual(f.validate(1), 1)
        self.assertEqual(f.validate(12), 12)
        self.assertEqual(f.validate(123), 123)
        with self.assertRaises(validation.ValidationError):
            f.validate(1234)

    def test_choices(self):
        f = self.get_field(choices=(1, 2))
        self.assertEqual(f.validate(1), 1)
        self.assertEqual(f.validate(2), 2)
        with self.assertRaises(validation.ValidationError):
            f.validate(3)
        with self.assertRaises(validation.ValidationError):
            f.validate(None)

    def test_choices_nullable(self):
        f = self.get_field(choices=(1, 2), null=True)
        self.assertEqual(f.validate(1), 1)
        self.assertEqual(f.validate(2), 2)
        self.assertEqual(f.validate(None), None)
        with self.assertRaises(validation.ValidationError):
            f.validate("3")

    def test_xml(self):
        f = self.get_field(null=True)
        self.assertEqual(self.to_xml(f, 1), "<Test>1</Test>")


class TestDecimalField(FieldTestMixin, TestCase):
    field_class = fields.DecimalField

    def test_value(self):
        f = self.get_field()
        self.assertEqual(f.validate(12), Decimal("12.00"))
        self.assertEqual(f.validate("12"), Decimal("12.00"))
        self.assertEqual(f.validate("12.345"), Decimal("12.345"))

    def test_default(self):
        f = self.get_field(default="7.0")
        self.assertEqual(f.clean_value(None), Decimal("7.0"))
        self.assertEqual(self.to_xml(f, None), "<Test>7.00</Test>")

    def test_max_length(self):
        f = self.get_field(max_length=4)
        self.assertEqual(f.validate(1), Decimal("1.00"))
        # 12 becomes 12.00 which is 5 characters long on a max_length of 4
        with self.assertRaises(validation.ValidationError):
            f.validate(12)

    def test_choices(self):
        f = self.get_field(choices=("1.1", "2.2"))
        self.assertEqual(f.validate("1.1"), Decimal("1.1"))
        self.assertEqual(f.validate(Decimal("2.2")), Decimal("2.2"))
        with self.assertRaises(validation.ValidationError):
            # 1.1 does not have an exact decimal representation
            f.validate(1.1)
        with self.assertRaises(validation.ValidationError):
            f.validate(None)

    def test_choices_nullable(self):
        f = self.get_field(choices=("1.1", "2.2"), null=True)
        self.assertEqual(f.validate("1.1"), Decimal("1.1"))
        self.assertEqual(f.validate(Decimal("2.2")), Decimal("2.2"))
        self.assertEqual(f.validate(None), None)
        with self.assertRaises(validation.ValidationError):
            # 1.1 does not have an exact decimal representation
            f.validate(1.1)

    def test_xml(self):
        f = self.get_field(null=True)
        self.assertEqual(self.to_xml(f, "12.345"), "<Test>12.34</Test>")
        self.assertEqual(self.to_xml(f, "34.567"), "<Test>34.57</Test>")


class TestDateField(FieldTestMixin, TestCase):
    field_class = fields.DateField

    def test_value(self):
        f = self.get_field()
        self.assertEqual(f.validate(datetime.date(2019, 1, 2)), datetime.date(2019, 1, 2))
        self.assertEqual(f.validate("2019-01-02"), datetime.date(2019, 1, 2))

    def test_default(self):
        f = self.get_field(default="2019-01-02")
        self.assertEqual(f.clean_value(None), datetime.date(2019, 1, 2))
        self.assertEqual(self.to_xml(f, None), "<Test>2019-01-02</Test>")

    def test_choices(self):
        f = self.get_field(choices=("2019-01-01", "2019-01-02"))
        self.assertEqual(f.validate("2019-01-01"), datetime.date(2019, 1, 1))
        self.assertEqual(f.validate("2019-01-02"), datetime.date(2019, 1, 2))
        with self.assertRaises(validation.ValidationError):
            f.validate(datetime.date(2019, 1, 3))
        with self.assertRaises(validation.ValidationError):
            f.validate(None)

    def test_choices_nullable(self):
        f = self.get_field(choices=("2019-01-01", "2019-01-02"), null=True)
        self.assertEqual(f.validate("2019-01-01"), datetime.date(2019, 1, 1))
        self.assertEqual(f.validate("2019-01-02"), datetime.date(2019, 1, 2))
        self.assertEqual(f.validate(None), None)
        with self.assertRaises(validation.ValidationError):
            f.validate(datetime.date(2019, 1, 3))

    def test_xml(self):
        f = self.get_field(null=True)
        self.assertEqual(self.to_xml(f, datetime.date(2019, 1, 2)), "<Test>2019-01-02</Test>")
        self.assertEqual(self.to_xml(f, "2019-01-02"), "<Test>2019-01-02</Test>")


class TestProgressivoInvioField(FieldTestMixin, TestCase):
    field_class = fields.ProgressivoInvioField

    def test_construct_default(self):
        f = self.get_field()

        # The field generates always different, always increasing values
        a = f.get_construct_default()
        b = f.get_construct_default()
        c = f.get_construct_default()
        d = f.get_construct_default()
        self.assertNotEqual(a, b)
        self.assertNotEqual(a, c)
        self.assertNotEqual(a, d)
        self.assertNotEqual(b, c)
        self.assertNotEqual(b, d)
        self.assertNotEqual(c, d)
        self.assertLess(a, b)
        self.assertLess(b, c)
        self.assertLess(c, d)
