#!/usr/bin/python3
import argparse
import logging
import contextlib
import sys
import os.path
import shutil
import subprocess
import a38.fattura as a38
import xml.etree.ElementTree as ET

log = logging.getLogger("test-parse")


class Fail(Exception):
    pass


class App:
    NAME = None

    def __init__(self, args):
        pass

    def load_fattura(self, pathname):
        if pathname.endswith(".p7m"):
            from a38.crypto import P7M
            p7m = P7M(pathname)
            return p7m.get_fattura()
        else:
            tree = ET.parse(pathname)
            return a38.auto_from_etree(tree.getroot())

    @classmethod
    def add_subparser(cls, subparsers):
        parser = subparsers.add_parser(cls.NAME, help=cls.__doc__.strip())
        parser.set_defaults(app=cls)
        return parser


class Diff(App):
    """
    show the difference between two fatture
    """
    NAME = "diff"

    def __init__(self, args):
        super().__init__(args)
        self.first = args.first
        self.second = args.second

    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        parser.add_argument("first", help="first input file (.xml or .xml.p7m)")
        parser.add_argument("second", help="second input file (.xml or .xml.p7m)")
        return parser

    def run(self):
        first = self.load_fattura(self.first)
        second = self.load_fattura(self.second)
        from a38.diff import Diff
        res = Diff()
        first.diff(res, second)
        if res:
            for d in res.differences:
                print(d)
            return 1


class Validate(App):
    """
    validate the contents of a fattura
    """
    NAME = "validate"

    def __init__(self, args):
        super().__init__(args)
        self.pathname = args.file

    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        parser.add_argument("file", help="input file (.xml or .xml.p7m)")
        return parser

    def run(self):
        f = self.load_fattura(self.pathname)
        from a38.validation import Validation
        res = Validation()
        f.validate(res)
        if res.warnings:
            for w in res.warnings:
                print(str(w), file=sys.stderr)
        if res.errors:
            for e in res.errors:
                print(str(e), file=sys.stderr)
            return 1


class Exporter(App):
    WRITE_MODE = None

    def __init__(self, args):
        super().__init__(args)
        self.files = args.files
        self.output = args.output

    @contextlib.contextmanager
    def open_output(self):
        if self.output is None:
            if "b" in self.WRITE_MODE:
                yield sys.stdout.buffer
            else:
                yield sys.stdout
        else:
            with open(self.output, self.WRITE_MODE) as out:
                yield out

    def run(self):
        with self.open_output() as out:
            for pathname in self.files:
                f = self.load_fattura(pathname)
                self.write(f, out)

    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        parser.add_argument("-o", "--output", help="output file (default: standard output)")
        parser.add_argument("files", nargs="+", help="input files (.xml or .xml.p7m)")
        return parser


class ExportJSON(Exporter):
    """
    output a fattura in JSON
    """
    NAME = "json"
    WRITE_MODE = "wt"

    def __init__(self, args):
        super().__init__(args)
        if args.indent == "no":
            self.indent = None
        else:
            try:
                self.indent = int(args.indent)
            except ValueError:
                raise Fail("--indent argument must be an integer on 'no'")

    def write(self, f, out):
        import json
        json.dump(f.to_jsonable(), out, indent=self.indent)
        out.write("\n")

    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        parser.add_argument("--indent", default="1", help="indentation space (default: 1, use 'no' for all in one line)")
        return parser


class ExportXML(Exporter):
    """
    output a fattura in XML
    """
    NAME = "xml"
    WRITE_MODE = "wb"

    def write(self, f, out):
        tree = f.build_etree()
        tree.write(out)
        out.write(b"\n")

    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        return parser


class ExportPython(Exporter):
    """
    output a fattura as Python code
    """
    NAME = "python"
    WRITE_MODE = "wt"

    def __init__(self, args):
        super().__init__(args)
        self.namespace = args.namespace
        if self.namespace == "":
            self.namespace = False
        self.unformatted = args.unformatted

    def get_code(self, f):
        code = f.to_python(namespace=self.namespace)
        if self.unformatted:
            return code

        try:
            from yapf.yapflib import yapf_api
        except ModuleNotFoundError:
            return code
        code, changed = yapf_api.FormatCode(code)
        return code

    def write(self, f, out):
        print(self.get_code(f), file=out)

    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        parser.add_argument("--namespace", default=None, help="namespace to use for the model classes (default: the module fully qualified name)")
        parser.add_argument("--unformatted", action="store_true", help="disable code formatting, outputting a single-line statement")
        return parser


class Renderer(App):
    def __init__(self, args):
        from a38.render import HAVE_LXML
        if not HAVE_LXML:
            raise Fail("python3-lxml is needed for XSLT based rendering")

        super().__init__(args)
        self.stylesheet = args.stylesheet
        self.files = args.files
        self.output = args.output
        self.force = args.force

        from a38.render import XSLTTransform
        self.transform = XSLTTransform(self.stylesheet)

    def run(self):
        for pathname in self.files:
            dirname = os.path.normpath(os.path.dirname(pathname))
            basename = os.path.basename(pathname)
            basename, ext = os.path.splitext(basename)
            output = self.output.format(dirname=dirname, basename=basename, ext=ext)
            if not self.force and os.path.exists(output):
                log.warning("%s: output file %s already exists: skipped", pathname, output)
            else:
                log.info("%s: writing %s", pathname, output)
            f = self.load_fattura(pathname)
            self.render(f, output)

    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        parser.add_argument("-f", "--force", action="store_true", help="overwrite existing output files")
        default_output = "{dirname}/{basename}{ext}." + cls.NAME
        parser.add_argument("-o", "--output",
                            default=default_output,
                            help="output file; use {dirname} for the source file path,"
                                 " {basename} for the source file name"
                                 " (default: '" + default_output + "'")
        parser.add_argument("stylesheet", help=".xsl/.xslt stylesheet file to use for rendering")
        parser.add_argument("files", nargs="+", help="input files (.xml or .xml.p7m)")
        return parser


class RenderHTML(Renderer):
    """
    render a Fattura as HTML using a .xslt stylesheet
    """
    NAME = "html"

    def render(self, f, output):
        html = self.transform(f)
        html.write(output)


class RenderPDF(Renderer):
    """
    render a Fattura as PDF using a .xslt stylesheet
    """
    NAME = "pdf"

    def __init__(self, args):
        super().__init__(args)
        self.wkhtmltopdf = shutil.which("wkhtmltopdf")
        if self.wkhtmltopdf is None:
            raise Fail("wkhtmltopdf is needed for PDF rendering")

    def render(self, f, output):
        self.transform.to_pdf(self.wkhtmltopdf, f, output)


class UpdateCAPath(App):
    """
    show the difference between two fatture
    """
    NAME = "update_capath"

    def __init__(self, args):
        super().__init__(args)
        self.destdir = args.destdir
        self.remove_old = args.remove_old

    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        parser.add_argument("destdir", help="CA certificate directory to update")
        parser.add_argument("--remove-old", action="store_true", help="remove old certificates")
        return parser

    def load_certs(self):
        from a38 import trustedlist as tl
        import re
        from collections import defaultdict

        re_clean_fname = re.compile(r"[^A-Za-z0-9_-]")

        eu_url = "https://ec.europa.eu/information_society/policy/esignature/trusted-list/tl-mp.xml"
        log.info("Downloading EU index from %s", eu_url)
        eu_tl = tl.load_url(eu_url)
        it_url = eu_tl.get_tsl_pointer_by_territory("IT")
        log.info("Downloading IT data from %s", it_url)
        trust_service_status_list = tl.load_url(it_url)

        by_name = defaultdict(list)
        for tsp in trust_service_status_list.trust_service_provider_list.trust_service_provider:
            for tsp_service in tsp.tsp_services.tsp_service:
                si = tsp_service.service_information
                if si.service_status not in (
                        "http://uri.etsi.org/TrstSvc/TrustedList/Svcstatus/recognisedatnationallevel",
                        "http://uri.etsi.org/TrstSvc/TrustedList/Svcstatus/granted"):
                    continue
                if si.service_type_identifier not in (
                        "http://uri.etsi.org/TrstSvc/Svctype/CA/QC",):
                    continue
                # print("identifier", si.service_type_identifier)
                # print("status", si.service_status)
                cert = []
                sn = []
                for di in si.service_digital_identity.digital_id:
                    if di.x509_subject_name is not None:
                        sn.append(di.x509_subject_name)
                    # if di.x509_ski is not None:
                    #    print("  SKI:", di.x509_ski)
                    if di.x509_certificate is not None:
                        from cryptography import x509
                        from cryptography.hazmat.backends import default_backend
                        import base64
                        der = base64.b64decode(di.x509_certificate)
                        cert.append(x509.load_der_x509_certificate(der, default_backend()))

                if len(cert) == 0:
                    raise RuntimeError("{} has no certificates".format(sn))
                elif len(cert) > 1:
                    raise RuntimeError("{} has {} certificates".format(sn, len(cert)))
                else:
                    from cryptography.x509.oid import NameOID
                    cert = cert[0]
                    cn = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)[0].value
                    # print("sn", sn)
                    # print(cert)
                    # print("full cn", cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME))
                    # print("cn", cn)
                    fname = re_clean_fname.sub("_", cn)
                    by_name[fname].append(cert)

        res = {}
        for name, certs in by_name.items():
            if len(certs) == 1:
                if name in res:
                    raise RuntimeError("{} already in result".format(name))
                res[name] = certs[0]
            else:
                for idx, cert in enumerate(certs, start=1):
                    idxname = name + "_a38_{}".format(idx)
                    if idxname in res:
                        raise RuntimeError("{} already in result".format(name))
                    res[idxname] = cert
        return res

    def run(self):
        from cryptography.hazmat.primitives import serialization
        certs = self.load_certs()
        if os.path.isdir(self.destdir):
            current = set(c for c in os.listdir(self.destdir) if c.endswith(".crt"))
        else:
            current = set()
            os.makedirs(self.destdir)
        for name, cert in certs.items():
            fname = name + ".crt"
            current.discard(fname)
            pathname = os.path.join(self.destdir, fname)
            with open(pathname, "wb") as fd:
                fd.write(cert.public_bytes(serialization.Encoding.PEM))
                log.info("%s: written", pathname)
        if self.remove_old:
            for fname in current:
                pathname = os.path.join(self.destdir, fname)
                os.unlink(pathname)
                log.info("%s: removed", pathname)

        subprocess.run(["openssl", "rehash", self.destdir], check=True)


def main():
    parser = argparse.ArgumentParser(description="Handle fattura elettronica files")
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")

    subparsers = parser.add_subparsers(help="actions", required=True)
    subparsers.dest = "command"

    ExportJSON.add_subparser(subparsers)
    ExportXML.add_subparser(subparsers)
    ExportPython.add_subparser(subparsers)
    Diff.add_subparser(subparsers)
    Validate.add_subparser(subparsers)
    RenderHTML.add_subparser(subparsers)
    RenderPDF.add_subparser(subparsers)
    UpdateCAPath.add_subparser(subparsers)

    # sp_validate = subparsers.add_parser("validate", help="validate a fattura")
    # sp_validate.set_defaults(app=run_validate)

    args = parser.parse_args()

    log_format = "%(levelname)s %(message)s"
    level = logging.WARN
    if args.debug:
        level = logging.DEBUG
    elif args.verbose:
        level = logging.INFO
    logging.basicConfig(level=level, stream=sys.stderr, format=log_format)

    app = args.app(args)
    res = app.run()
    if isinstance(res, int):
        sys.exit(res)


if __name__ == "__main__":
    try:
        main()
    except Fail as e:
        print(e, file=sys.stderr)
        sys.exit(1)
    except Exception:
        log.exception("uncaught exception")
